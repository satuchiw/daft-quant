"""
Test script to verify that trades execute at next bar's open (no look-ahead bias)
"""
import pandas as pd
import sys
import os

sys.path.append(os.path.join(os.getcwd(), 'src'))

from backtest.engine import Backtester
from strategy.base_strategy import BaseStrategy

class SimpleTestStrategy(BaseStrategy):
    """
    Simple strategy that buys when close < 100 and sells when close > 110
    We'll track what price we think we're buying/selling at
    """
    def __init__(self):
        super().__init__()
        self.signals = []
    
    def on_init(self):
        self.signals = []
    
    def on_bar(self, bar):
        close = bar['close']
        dt = bar['datetime']
        
        # Track signals with the close price we see
        if close < 100:
            self.signals.append({
                'datetime': dt,
                'signal': 'buy',
                'close_seen': close
            })
            return "buy"
        elif close > 110:
            self.signals.append({
                'datetime': dt,
                'signal': 'sell',
                'close_seen': close
            })
            return "sell"
        return "hold"
    
    def on_stop(self):
        pass

def main():
    print("=" * 60)
    print("Testing Execution Timing (Look-Ahead Bias Fix)")
    print("=" * 60)
    
    # Create test data where we can clearly see the execution timing
    dates = pd.date_range(start='2024-01-01', periods=10, freq='D')
    
    # Create specific price pattern:
    # Day 0: close=95 (should trigger BUY signal)
    # Day 1: open=98 (BUY should execute here)
    # Day 5: close=115 (should trigger SELL signal)
    # Day 6: open=112 (SELL should execute here)
    
    prices = [95, 98, 102, 105, 108, 115, 112, 110, 108, 105]
    
    df = pd.DataFrame({
        'open': [p + 1 for p in prices],  # Open slightly higher
        'high': [p + 2 for p in prices],
        'low': [p - 1 for p in prices],
        'close': prices,
        'volume': [10000] * 10
    }, index=dates)
    
    # Adjust to have realistic open prices
    df.loc[dates[1], 'open'] = 98  # Day 1 open (after buy signal on day 0)
    df.loc[dates[6], 'open'] = 112  # Day 6 open (after sell signal on day 5)
    
    print("\nTest Data:")
    print(df[['open', 'close']].to_string())
    
    # Run backtest
    strategy = SimpleTestStrategy()
    backtester = Backtester(
        data=df,
        strategy=strategy,
        initial_capital=10000,
        commission_rate=0.0003,
        stamp_duty=0.001
    )
    
    backtester.run()
    results = backtester.get_results()
    
    print("\n" + "=" * 60)
    print("Signal Generation vs Trade Execution:")
    print("=" * 60)
    
    # Show signals generated
    print("\nSignals Generated by Strategy:")
    for sig in strategy.signals:
        print(f"  {sig['datetime'].date()}: {sig['signal'].upper()} signal (saw close={sig['close_seen']})")
    
    # Show actual trades executed
    print("\nTrades Actually Executed:")
    trades_df = pd.DataFrame(backtester.trades)
    if not trades_df.empty:
        for idx, trade in trades_df.iterrows():
            print(f"  {trade['datetime'].date()}: {trade['type'].upper()} at price={trade['price']:.2f}")
    
    # Verification
    print("\n" + "=" * 60)
    print("Verification:")
    print("=" * 60)
    
    if len(backtester.trades) >= 2:
        buy_trade = backtester.trades[0]
        sell_trade = backtester.trades[1]
        
        buy_signal_date = strategy.signals[0]['datetime'].date()
        buy_exec_date = buy_trade['datetime'].date()
        buy_exec_price = buy_trade['price']
        
        sell_signal_date = strategy.signals[1]['datetime'].date()
        sell_exec_date = sell_trade['datetime'].date()
        sell_exec_price = sell_trade['price']
        
        print(f"\nBUY Order:")
        print(f"  Signal generated on: {buy_signal_date}")
        print(f"  Executed on: {buy_exec_date}")
        print(f"  Days delayed: {(buy_exec_date - buy_signal_date).days}")
        print(f"  Execution price: {buy_exec_price:.2f}")
        print(f"  Expected (next open): {df.loc[df.index[1], 'open']:.2f}")
        
        print(f"\nSELL Order:")
        print(f"  Signal generated on: {sell_signal_date}")
        print(f"  Executed on: {sell_exec_date}")
        print(f"  Days delayed: {(sell_exec_date - sell_signal_date).days}")
        print(f"  Execution price: {sell_exec_price:.2f}")
        print(f"  Expected (next open): {df.loc[df.index[6], 'open']:.2f}")
        
        # Check if execution is at next bar's open
        buy_correct = (buy_exec_date - buy_signal_date).days == 1
        sell_correct = (sell_exec_date - sell_signal_date).days == 1
        
        print("\n" + "=" * 60)
        if buy_correct and sell_correct:
            print("✓ SUCCESS: Trades execute at NEXT bar's open (no look-ahead bias)")
        else:
            print("✗ FAILED: Trades are not executing at next bar's open")
        print("=" * 60)
    else:
        print("Not enough trades to verify")

if __name__ == "__main__":
    main()
